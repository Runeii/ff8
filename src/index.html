<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Walkmesh Renderer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }
  </style>
</head>

<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Basic setup
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100000000);
    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const launch = async () => {
      // Placeholder data object (replace with your actual data)
      let response = await fetch('/output/bdin3.json')
      let data = await response.json()

      let xTrans = 0, yTrans = 0, distance = 5;
      let xRot = 0, yRot = 0, zRot = 0;
      let camID = 0;
      let _drawLine = false;
      let _lineToDrawPoint1 = new THREE.Vector3();
      let _lineToDrawPoint2 = new THREE.Vector3();
      let _selectedTriangle = -1;
      let _selectedGate = -1;
      let _selectedDoor = -1;

      // Draw triangles and lines
      const material = new THREE.LineBasicMaterial({ color: 0xFFFFFF });

      data.walkmesh.forEach((triangle, i) => {
        // Draw triangle lines
        drawIdLine(scene, triangle.vertices[0], triangle.vertices[1], material);
        drawIdLine(scene, triangle.vertices[1], triangle.vertices[2], material);
        drawIdLine(scene, triangle.vertices[2], triangle.vertices[0], material);
      });

      function animate() {
        // Apply translations
        camera.position.set(xTrans, yTrans, distance);

        // Handle rotation
        camera.rotation.set(THREE.Math.degToRad(xRot), THREE.Math.degToRad(yRot), THREE.Math.degToRad(zRot));

        // Camera settings based on data
        const cam = data.camera;

        let camAxisX = new THREE.Vector3(cam.camera_axis[0].x / 4096.0, cam.camera_axis[0].y / 4096.0, cam.camera_axis[0].z / 4096.0);
        let camAxisY = new THREE.Vector3(-cam.camera_axis[1].x / 4096.0, -cam.camera_axis[1].y / 4096.0, -cam.camera_axis[1].z / 4096.0);
        let camAxisZ = new THREE.Vector3(cam.camera_axis[2].x / 4096.0, cam.camera_axis[2].y / 4096.0, cam.camera_axis[2].z / 4096.0);

        let camPos = new THREE.Vector3(cam.camera_position[0] / 4096.0, -cam.camera_position[1] / 4096.0, cam.camera_position[2] / 4096.0);

        let tx = -(camPos.dot(camAxisX));
        let ty = -(camPos.dot(camAxisY));
        let tz = -(camPos.dot(camAxisZ));

        camera.position.set(tx, ty, tz);
        camera.lookAt(tx + camAxisZ.x, ty + camAxisZ.y, tz + camAxisZ.z);

        renderer.render(scene, camera);
      }

      renderer.setAnimationLoop(animate);

      function drawIdLine(scene, vertex1, vertex2, material) {
        const geometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(vertex1.x / 4096.0, vertex1.y / 4096.0, vertex1.z / 4096.0),
          new THREE.Vector3(vertex2.x / 4096.0, vertex2.y / 4096.0, vertex2.z / 4096.0)
        ]);

        const line = new THREE.Line(geometry, material);

        scene.add(line);
      }

      function drawGateway(scene, vertex1, vertex2, material) {
        const geometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(vertex1.x / 4096.0, vertex1.y / 4096.0, vertex1.z / 4096.0),
          new THREE.Vector3(vertex2.x / 4096.0, vertex2.y / 4096.0, vertex2.z / 4096.0)
        ]);

        const line = new THREE.Line(geometry, material);
        scene.add(line);
      }

      function drawTrigger(scene, vertex1, vertex2, material) {
        const geometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(vertex1.x / 4096.0, vertex1.y / 4096.0, vertex1.z / 4096.0),
          new THREE.Vector3(vertex2.x / 4096.0, vertex2.y / 4096.0, vertex2.z / 4096.0)
        ]);

        const line = new THREE.Line(geometry, material);
        scene.add(line);
      }

      function drawLine(scene, vertex1, vertex2, material) {
        const geometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(vertex1.x / 4096.0, vertex1.y / 4096.0, vertex1.z / 4096.0),
          new THREE.Vector3(vertex2.x / 4096.0, vertex2.y / 4096.0, vertex2.z / 4096.0)
        ]);

        const line = new THREE.Line(geometry, material);
        scene.add(line);
      }

      function drawTrianglePoints(scene, triangle, material) {
        const points = [
          new THREE.Vector3(triangle.vertices[0].x / 4096.0, triangle.vertices[0].y / 4096.0, triangle.vertices[0].z / 4096.0),
          new THREE.Vector3(triangle.vertices[1].x / 4096.0, triangle.vertices[1].y / 4096.0, triangle.vertices[1].z / 4096.0),
          new THREE.Vector3(triangle.vertices[2].x / 4096.0, triangle.vertices[2].y / 4096.0, triangle.vertices[2].z / 4096.0)
        ];

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const pointMesh = new THREE.Points(geometry, material);
        scene.add(pointMesh);
      }

      function drawGatewayPoints(scene, vertex1, vertex2, material) {
        const points = [
          new THREE.Vector3(vertex1.x / 4096.0, vertex1.y / 4096.0, vertex1.z / 4096.0),
          new THREE.Vector3(vertex2.x / 4096.0, vertex2.y / 4096.0, vertex2.z / 4096.0)
        ];

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const pointMesh = new THREE.Points(geometry, material);
        scene.add(pointMesh);
      }

      function drawTriggerPoints(scene, vertex1, vertex2, material) {
        const points = [
          new THREE.Vector3(vertex1.x / 4096.0, vertex1.y / 4096.0, vertex1.z / 4096.0),
          new THREE.Vector3(vertex2.x / 4096.0, vertex2.y / 4096.0, vertex2.z / 4096.0)
        ];

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const pointMesh = new THREE.Points(geometry, material);
        scene.add(pointMesh);
      }

    }
    launch()
  </script>
</body>

</html>