const p="ff8-gl-cache-v1",m=e=>{let t;const n=new Set,a=(c,E)=>{const f=typeof c=="function"?c(t):c;if(!Object.is(f,t)){const T=t;t=E??(typeof f!="object"||f===null)?f:Object.assign({},t,f),n.forEach(A=>A(t,T))}},o=()=>t,s={setState:a,getState:o,getInitialState:()=>u,subscribe:c=>(n.add(c),()=>n.delete(c))},u=t=e(a,o,s);return s},F=e=>e?m(e):m,b={isEnablingOffline:!1,isOfflineEnabled:!1,progress:{current:0,total:0}},L=()=>{const{getState:e,setState:t,subscribe:n}=F(()=>structuredClone(b)),a=()=>{const s=navigator.serviceWorker?.controller;if(!s){console.warn("Service worker not ready, cannot enable offline mode");return}s.postMessage({type:"RECOVER_STATE"})},o=async()=>{const s=navigator.serviceWorker?.controller;if(!s){console.warn("Service worker not ready, cannot enable offline mode");return}s.postMessage({type:"ENABLE_OFFLINE"})},r=async()=>{const s=navigator.serviceWorker?.controller;if(!s){console.warn("Service worker not ready, cannot disable offline mode");return}s.postMessage({type:"DISABLE_OFFLINE"})},w=async()=>{try{const s=await navigator.serviceWorker.register("/_sw.js");console.log("Service worker registered:",s.scope),navigator.serviceWorker.addEventListener("message",c=>{t(c.data)});const u=await navigator.serviceWorker.ready;console.log("Service worker is ready:",u.active?.state),await a()}catch(s){console.error("OfflineController initialization failed:",s)}};return"serviceWorker"in navigator&&w(),{getState:e,subscribe:n,enableOfflineMode:o,disableOfflineMode:r}};L();const l="offline-state",v="preserved-state",y=e=>new Promise((t,n)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>n(e.error)}),O=()=>new Promise((e,t)=>{const n=indexedDB.open("OfflineSettings",2);n.onerror=()=>t(n.error),n.onupgradeneeded=a=>{const o=a.target.result;o.objectStoreNames.contains(l)||o.createObjectStore(l)},n.onsuccess=a=>e(a.target.result)}),_=async()=>{const a=(await O()).transaction([l],"readonly").objectStore(l).get(v);return y(a).catch(()=>({}))},$=async e=>{const o=(await O()).transaction([l],"readwrite").objectStore(l).put(e,v);return y(o)},I="/.vite/manifest.json",R="/custom-manifest.json",j=async()=>{const e=await fetch(R);if(!e.ok)throw new Error(`Failed to load manifest: ${e.status}`);const t=await e.json();if(!Array.isArray(t))throw new Error("Manifest must be a JSON array");return console.log(`Loaded ${t.length} files from custom manifest`),t},C=async()=>{const e=await fetch(I);if(!e.ok)throw new Error(`Failed to load Vite manifest: ${e.status}`);const t=await e.json();return console.log(`Loaded ${t.length} files from Vite manifest`),t},W=async()=>{const e=await j(),t=await C();let n=e.map(a=>[a,a]);return t&&(n=n.concat(Object.entries(t).map(([a,{file:o}])=>[a,o]))),n},N=e=>new Promise(t=>setTimeout(t,e)),P=async(e,t)=>{const n=await caches.open(p),a=await fetch(t);if(!a.ok)throw new Error(`Failed to fetch file: ${t}`);console.log(`Caching file: ${e} -> ${t}`),await n.put(e,a);const{progress:o}=g();await i({progress:{...o,current:o.current+1}})};let S=!1;const k=async()=>{if(S)return;S=!0,await i({isEnablingOffline:!0,isOfflineEnabled:!1});const e=await W();console.log("Enabling offline mode with manifest:",e);const t=g();t.progress.total&&t.progress.total!==e.length&&await M();const n=g();await i({isEnablingOffline:!0,isOfflineEnabled:!1,progress:{...n.progress,total:e.length}});let a=[...e];n.progress.current>0&&(a=e.slice(n.progress.current),console.log(`Resuming from ${n.progress.current} files already cached`));let o=0;for await(const[r,w]of a)await P(r,w),o++,o%500===0&&(console.log(`Cached ${o} files`),await N(500));await i({isEnablingOffline:!1,isOfflineEnabled:!0})},M=async()=>{const e=await caches.keys();await Promise.all(e.map(t=>caches.delete(t))),await i({isEnablingOffline:!1,isOfflineEnabled:!1,progress:{current:0,total:0}})},V=self,d=structuredClone(b),g=()=>d,U=async()=>{(await V.clients.matchAll()).forEach(t=>t.postMessage(d))},i=async e=>{Object.assign(d,e),await $(d),await U()},B=async()=>{console.log("Recovering Service Worker State:",d);const e=await _();await i(e);const t=g();setTimeout(()=>{t.isEnablingOffline&&!t.isOfflineEnabled&&k()},1e3)},D=async e=>{const t=new URL(e.url);if(!["http:","https:"].includes(t.protocol))return fetch(e);const{isOfflineEnabled:n}=await g();if(console.log(`Handling fetch for: ${t.pathname}, Offline mode: ${n}`),!n)return fetch(e);const a=await caches.match(e);if(console.log(`Cache match for ${t.pathname}:`,!!a),a)return console.log(`Serving from cache: ${t.pathname}`),a;try{const o=await fetch(e);return o.ok&&e.method==="GET"&&(await caches.open(p)).put(e,o.clone()),o}catch(o){if(console.error(`Fetch failed for ${t.pathname}:`,o),e.destination==="document"){const r=await caches.match("/");if(r)return console.log("Serving fallback page"),r}throw new Error("Fetch failed and no cached version available")}},h=self,x=async({type:e})=>{switch(console.log(`Service Worker: Received message of type ${e}`),e){case"RECOVER_STATE":await B();break;case"ENABLE_OFFLINE":await k();break;case"DISABLE_OFFLINE":await M();break;default:console.warn(`Service Worker: Unknown message type: ${e}`)}};h.addEventListener("message",e=>x(e.data));h.addEventListener("install",()=>{console.log("Service Worker: Installing"),h.skipWaiting()});h.addEventListener("fetch",e=>{e.respondWith(D(e.request))});
