const m="ff8-gl-cache-v1";const S=e=>{let t;const o=new Set,a=(i,p)=>{const g=typeof i=="function"?i(t):i;if(!Object.is(g,t)){const A=t;t=p??(typeof g!="object"||g===null)?g:Object.assign({},t,g),o.forEach(F=>F(t,A))}},r=()=>t,s={setState:a,getState:r,getInitialState:()=>w,subscribe:i=>(o.add(i),()=>o.delete(i))},w=t=e(a,r,s);return s},L=e=>e?S(e):S,v={isEnablingOffline:!1,isOfflineEnabled:!1,progress:{current:0,total:0}},_=()=>{const{getState:e,setState:t,subscribe:o}=L(()=>structuredClone(v)),a=()=>{const s=navigator.serviceWorker?.controller;if(!s){console.warn("Service worker not ready, cannot enable offline mode");return}s.postMessage({type:"RECOVER_STATE"})},r=async()=>{const s=navigator.serviceWorker?.controller;if(!s){console.warn("Service worker not ready, cannot enable offline mode");return}s.postMessage({type:"ENABLE_OFFLINE"})},n=async()=>{const s=navigator.serviceWorker?.controller;if(!s){console.warn("Service worker not ready, cannot disable offline mode");return}s.postMessage({type:"DISABLE_OFFLINE"})},c=async()=>{try{const s=await navigator.serviceWorker.register("/_sw.js");console.log("Service worker registered:",s.scope),navigator.serviceWorker.addEventListener("message",i=>{t(i.data)});const w=await navigator.serviceWorker.ready;console.log("Service worker is ready:",w.active?.state),await a()}catch(s){console.error("OfflineController initialization failed:",s)}};return"serviceWorker"in navigator&&c(),{getState:e,subscribe:o,enableOfflineMode:r,disableOfflineMode:n}};_();const d="offline-state",y="preserved-state",O=e=>new Promise((t,o)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>o(e.error)}),k=()=>new Promise((e,t)=>{const o=indexedDB.open("OfflineSettings",2);o.onerror=()=>t(o.error),o.onupgradeneeded=a=>{const r=a.target.result;r.objectStoreNames.contains(d)||r.createObjectStore(d)},o.onsuccess=a=>e(a.target.result)}),I=async()=>{const a=(await k()).transaction([d],"readonly").objectStore(d).get(y);return O(a).catch(()=>({}))},M=async e=>{const r=(await k()).transaction([d],"readwrite").objectStore(d).put(e,y);return O(r)},C=self,h=structuredClone(v),u=()=>h,N=async()=>{(await C.clients.matchAll()).forEach(t=>t.postMessage(h))},f=async e=>{Object.assign(h,e),await M(h),await N()},R=async()=>{console.log("Recovering Service Worker State:",h);const e=await I();await f(e)},W=async e=>{const t=new URL(e.url);if(!["http:","https:"].includes(t.protocol))return fetch(e);const{isOfflineEnabled:o}=await u();if(!o)return fetch(e);const a=await caches.match(e);if(a)return console.log(`Serving from cache: ${t.pathname}`),a;try{const r=await fetch(e);return r.ok&&e.method==="GET"&&(await caches.open(m)).put(e,r.clone()),r}catch(r){if(console.error(`Fetch failed for ${t.pathname}:`,r),e.destination==="document"){const n=await caches.match("/");if(n)return console.log("Serving fallback page"),n}throw new Error("Fetch failed and no cached version available")}},$=async(e,t)=>{const o=n=>new Promise(c=>setTimeout(c,n)),a=()=>new Promise(n=>{if(navigator.onLine){n();return}const c=()=>{window.removeEventListener("online",c),n()};window.addEventListener("online",c)}),r=async()=>{navigator.onLine||(console.log("Network offline, waiting for connection..."),await a());try{const n=await fetch(e,{signal:t});if(!n.ok)throw new Error(`HTTP ${n.status}: ${n.statusText}`);return n}catch(n){throw(n instanceof TypeError||n instanceof TypeError&&n.message.includes("NetworkError"))&&(console.log("Network error detected, waiting for connection..."),await a()),n}};for(;;)try{return await r()}catch(n){console.log(`Fetch failed for ${e}, retrying in 2 seconds...`,n),await o(2e3)}},P="/custom-manifest.json",j=async()=>{const e=await fetch(P);if(!e.ok)throw new Error(`Failed to load manifest: ${e.status}`);const t=await e.json();if(!Array.isArray(t))throw new Error("Manifest must be a JSON array");return console.log(`Loaded ${t.length} files from custom manifest`),t},B=async(e,t,o,a)=>{const r=Array.from({length:Math.ceil(t.length/e)},(n,c)=>t.slice(c*e,(c+1)*e));for(const[n,c]of r.entries()){if(a?.aborted){console.warn("Batch processing aborted");break}await Promise.all(c.map((s,w)=>o(s,n*e+w,c)))}},D=async(e,t)=>{const o=await caches.open(m);if(await o.match(e))return;const a=await $(t);if(!a.ok)throw new Error(`Failed to fetch file: ${t}`);console.log(`Caching file: ${e} -> ${t}`),await o.put(e,a);const{progress:r}=u();await f({progress:{...r,current:r.current+1}})},U=e=>new Promise(t=>setTimeout(t,e));let b=!1,l=null;const x=async()=>{if(b)return;b=!0,await f({isEnablingOffline:!0,isOfflineEnabled:!1});const e=await j(),t=u();t.progress.total&&t.progress.total!==e.length&&await T();const o=u();if(await f({isEnablingOffline:!0,isOfflineEnabled:!1,progress:{...o.progress,total:e.length}}),await U(1e3),l=new AbortController,await B(20,e,async a=>{await D(a,a)},l.signal),!l||l.signal.aborted){console.warn("Offline mode enabling was aborted");return}await f({isEnablingOffline:!1,isOfflineEnabled:!0})},T=async()=>{b=!1,l&&(l.abort(),l=null),await f({isEnablingOffline:!1,isOfflineEnabled:!1,progress:{current:0,total:0}});const e=await caches.keys();await Promise.all(e.map(t=>caches.delete(t)))},E=self,H=async({type:e})=>{switch(console.log(`Service Worker: Received message of type ${e}`),e){case"RECOVER_STATE":await R();break;case"ENABLE_OFFLINE":await x();break;case"DISABLE_OFFLINE":await T();break;default:console.warn(`Service Worker: Unknown message type: ${e}`)}};E.addEventListener("message",e=>H(e.data));E.addEventListener("install",()=>{console.log("Service Worker: Installing"),E.skipWaiting()});E.addEventListener("fetch",e=>{e.respondWith(W(e.request))});
